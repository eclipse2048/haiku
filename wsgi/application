#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
#  application (web-frontend for Haiku / Automatoetry)
#
#  Copyright 2013 Tobias Radloff <mail@tobias-radloff.de>
#
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 2 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software
#  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
#  MA 02110-1301, USA.
#
#

from __future__ import division, absolute_import # Aufwärtskompatibilität
import os

# lokal oder Openshift?
if os.environ.has_key("OPENSHIFT_PYTHON_DIR"]:
	RUNS_ON_OPENSHIFT = True
else:
	RUNS_ON_OPENSHIFT = False

# Virtual Environment für Openshift
if RUNS_ON_OPENSHIFT:
	virtenv = os.environ["OPENSHIFT_PYTHON_DIR"] + "/virtenv/"
	os.environ["PYTHON_EGG_CACHE"] = os.path.join(virtenv, "lib/python2.6/site-packages")
	virtualenv = os.path.join(virtenv, "bin/activate_this.py")
	try:
		execfile(virtualenv, dict(__file__=virtualenv))
	except IOError:
		pass

#
# IMPORTANT: Put any additional includes below this line.  If placed above this
# line, it's possible required libraries won't be in your searchable path
#

import web # @TODO Von web.py auf flask umstellen
import json
from automatoetry import AutoPoemSpecimen

# Initialisierungsvariablen für web.py
urls = ("/", "start", "/do", "automatoetry")
render = web.template.render(os.path.abspath(os.path.dirname(__file__)) + "/templates/")
if RUNS_ON_OPENSHIFT:
	application = web.application(urls, globals()).wsgifunc()
else:
	app = web.application(urls, globals()) # Achtung: erzeugt ImportError, falls kein Symlink application.py -> application existiert

myPoem = AutoPoemSpecimen()

class start:
	""" Definiert Formular und GET- und POST-Methoden für die Startwebseite des Projekts,
		wo der User den Genotyp für Generation 1 bestimmt. Das zugehörige Template ist "templates/start.html".
	"""


	form = web.form.Form(
		web.form.Textbox(
			"seedword",
			web.form.notnull,
			size = 19,
			class_ = "textfield",
			description = "Seedwort:"
		),
		web.form.Textbox(
			"genes",
			web.form.notnull,
			web.form.regexp(r"^[a-z ]*$", "Bitte nur Kleinbuchstaben"),
			web.form.regexp(r"^[a-z]{5} [a-z]{7} [a-z]{5}$", "Gene müssen 5, 7, 5 Zeichen enthalten, jeweils durch Leerzeichen getrennt"), #
			size = 19,
			maxlength = 19,
			class_ = "textfield",
			description = "Gene:"
		),
		web.form.Button(
			"Los",
			class_ = "los"
		)
	)
	""" Eingabeformular für Seedwort und Gene. Buttons für neue Zufallswerte sind nicht
		definiert, sie werden im Template hinzugefügt (@TODO: wobei sich das evtl.
		streamlinen ließe).
	"""


	def GET(self):
		""" Gibt das Formular für Gene und Seedwort zurück, befüllt mit Zufallswerten.
		"""

		# global myPoem ist hier unnötig, da die Instanz unverändert bleibt
		f = self.form()
		f["seedword"].set_value(myPoem.createRandomSeedword())
		f["genes"].set_value(myPoem.createRandomGenes())
		return render.start(f)


	def POST(self):
		""" Wird von den Buttons auf "templates/start.html" aufgerufen. Je nach
			Aufrufer wird unterschiedlich verfahren:
			- Neues Seedwort / Neue Gene: Funktion gibt neue Zufallswerte zurück
			- Los-Button: Funktion erzeugt myPoem mit den Werten aus dem Formular
			neu und ruft die Seite "do" auf.
		"""

		global myPoem
		input = web.input(Los="")
		print "/ POST: input ist", input #DEBUG

		# "Los"-Button
		if input["Los"] != "":
			f = self.form()
			if not f.validates():
				return render.start(f)
			myPoem = AutoPoemSpecimen([f.d.seedword, f.d.genes])
			print "/ POST: Elter lautet", myPoem.getGenotype() #DEBUG
			raise web.seeother("do")

		# "Neu"-Button: neues Seedwort oder Gene zurückgeben
		if input["caller"] == "newSeedword":
			return myPoem.createRandomSeedword()
		elif input["caller"] == "newGenes":
			return myPoem.createRandomGenes()


class automatoetry:
	""" Definiert GET- und POST-Methoden für die Hauptwebseite des Projekts,
		wo der User zwischen den Kindern einer Generation entscheidet, welches
		sich weiter fortpflanzt. Das zugehörige Template ist "templates/automatoetry.html".
	"""


	def GET(self):
		""" Gibt Seedwort, Gene und Phänotype für Generation 1 zurück (den Phänotypen als
			Liste von Zeilen).
		"""
		global myPoem
		return render.automatoetry(myPoem.getGenotype()[0], myPoem.getGenotype()[1], myPoem.getPhenotype().split("\n"))


	def POST(self):
		""" Sorgt für den Wechsel zur neuen Generation und gibt deren zwei neue Kinder zurück.
		"""

		global myPoem
		input = web.input()
		print "/do POST: input ist:", input #DEBUG
		print "/do POST: Kinder des Elter sind", myPoem.getChildren() #DEBUG

		# @TODO Abfangen, ob beide Kinder wirklich existieren oder ob procreateN aufgrund von libleipzig-Fehlern keine / zu wenige Ergebnisse liefert. Das führt nämlich dazu, dass das überlebende Kind statt mit den Genen des Elter mit Zufallswerten instanziiert wird.

		# Welches Kind wird neuer Elter?
		if input["child"] == "l":
			myPoem = myPoem.getChildren()[0]
		elif input["child"] == "r":
			myPoem = myPoem.getChildren()[1]
		# Allererste Generation: nichts machen (Codeblock ist redundant)
#		elif input["child"] == "0":
#			pass
		print "/do POST: Neuer Elter ist:", myPoem.getGenotype() #DEBUG

		# Kinder erzeugen und als JSON-Objekt zurückgeben
		children = myPoem.procreateN(2)
		return json.dumps([[child.getGenotype(), child.getPhenotype().replace("\n", "<br/>")] for child in children])


if __name__ == '__main__':
	if RUNS_ON_OPENSHIFT: # starte ggf. in Openshift-Umgebung
		from wsgiref.simple_server import make_server
		httpd = make_server('localhost', 80, application)
		httpd.serve_forever()
	else: # starte lokal mit web.py
		app.run()
