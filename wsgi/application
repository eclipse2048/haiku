#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
#  application (web-frontend for Haiku / Automatoetry)
#
#  Copyright 2013 Tobias Radloff <mail@tobias-radloff.de>
#
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 2 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software
#  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
#  MA 02110-1301, USA.
#


from __future__ import division, absolute_import # Aufwärtskompatibilität
import os

# lokal oder Openshift?
if os.environ.has_key("OPENSHIFT_PYTHON_DIR"):
	RUNS_ON_OPENSHIFT = True
else:
	RUNS_ON_OPENSHIFT = False

# Virtual Environment für Openshift
if RUNS_ON_OPENSHIFT:
	virtenv = os.environ["OPENSHIFT_PYTHON_DIR"] + "/virtenv/"
	os.environ["PYTHON_EGG_CACHE"] = os.path.join(virtenv, "lib/python2.6/site-packages")
	virtualenv = os.path.join(virtenv, "bin/activate_this.py")
	try:
		execfile(virtualenv, dict(__file__=virtualenv))
	except IOError:
		pass

# Zusätzliche Module erst ab hier importieren (wg. Openshift virtual environment)
import web # @TODO Von web.py auf flask umstellen
import json
from automatoetry import AutoPoemSpecimen, HaikuError

# Initialisierungsvariablen für web.py
urls = ("/", "start", "/do", "automatoetry")
render = web.template.render(os.path.abspath(os.path.dirname(__file__)) + "/templates/")
if RUNS_ON_OPENSHIFT:
	application = web.application(urls, globals()).wsgifunc()
else:
	app = web.application(urls, globals()) # Achtung: erzeugt ImportError, falls kein Symlink application.py -> application existiert

# globale Haiku-Variable
myPoem = None


class start:
	""" Definiert Formular und GET- und POST-Methoden für die
		Startwebseite des Projekts, auf der der User den Genotyp für
		Generation 1 bestimmt. Das zugehörige Template ist
		"templates/start.html".
	"""

	# @TODO: Auswahlkästchen für die Developfkt. hinzufügen
	form = web.form.Form(
		web.form.Textbox(
			"seedword",
			web.form.notnull,
			size = 19,
			class_ = "textfield",
			description = "Seedwort:"
		),
		web.form.Button(
			"Neues Zufallswort",
			id = "newSeedword",
			class_ = "button"
		),
		web.form.Textbox(
			"genes",
			web.form.notnull,
			web.form.regexp(r"^[a-z ]*$", "Bitte nur Kleinbuchstaben"),
			web.form.regexp(r"^[a-z]{5} [a-z]{7} [a-z]{5}$", "Gene müssen 5, 7, 5 Zeichen enthalten, jeweils durch Leerzeichen getrennt"), #
			size = 19,
			maxlength = 19,
			class_ = "textfield",
			description = "Gene:"
		),
		web.form.Button(
			"Neue Gene",
			id = "newGenes",
			class_ = "button"
		),
		web.form.Button(
			"Los",
			class_ = "los"
		)
	)


	def GET(self):
		""" Gibt das Formular für Gene und Seedwort zurück, befüllt mit
			Zufallswerten.
		"""
		# neues Start-Haiku erzeugen
		global myPoem
		myPoem = AutoPoemSpecimen()
#		print "/ GET: lese myPoem aus:\n%s \n%s \n%s \n%s" %(myPoem.getGenotype(), myPoem.getPhenotype(), myPoem.getParent(), myPoem.getChildren()) #DEBUG

		# Formular erzeugen und mit Werten füllen
		f = self.form()
		f["seedword"].set_value(myPoem.getGenotype()[0])
		f["genes"].set_value(myPoem.getGenotype()[1])
		return render.start(f)


	def POST(self):
		""" Wird von den Buttons auf "templates/start.html" aufgerufen.
			Je nach Aufrufer wird unterschiedlich verfahren:
			- Neues Seedwort / Neue Gene: Funktion gibt neue
			Zufallswerte zurück
			- Los-Button: Funktion erzeugt myPoem mit den Werten aus dem
			Formular neu und ruft Seite "do" auf.
		"""

		global myPoem
		input = web.input(Los="")
		print "/ POST: input ist", input #DEBUG

		# "Los"-Button
		if input["Los"] != "":
			f = self.form()
			if not f.validates():
				return render.start(f)
			myPoem = AutoPoemSpecimen(f.d.seedword, f.d.genes)
			print "/ POST: Elter lautet", myPoem.getGenotype() #DEBUG
			raise web.seeother("do")

		# "Neu"-Button: neues Seedwort oder Gene zurückgeben
		if input["caller"] == "newSeedword":
			print "/ POST: Neues Seedword angefordert" #DEBUG
			return myPoem.getRandomSeedword()
		elif input["caller"] == "newGenes":
			print "/ POST: Neue Gene angefordert" #DEBUG
			return myPoem.getRandomGenes()


class automatoetry:
	""" Definiert GET- und POST-Methoden für die Hauptwebseite des
		Projekts, auf der der User zwischen den Kindern einer Generation
		entscheidet, welches sich weiter fortpflanzt. Das zugehörige
		Template ist "templates/automatoetry.html".
	"""


	def GET(self):
		""" Gibt Seedwort, Gene und Phänotype für Generation 1 zurück
			(den Phänotypen als Liste von Zeilen).
		"""
		global myPoem
		print "/do GET: Genotyp ist", myPoem.getGenotype() #DEBUG
# @TODO: getPhenotype()-Aufrufe in try: except HaikuError-Block einbetten. Aber wie einen aufgetetenen Fehler behandeln?
		return render.automatoetry(myPoem.getGenotype()[0], myPoem.getGenotype()[1], myPoem.getPhenotype().split("\n"))


	def POST(self):
		""" Erledigt POST-Requests. Sorgt für den Wechsel zur neuen
			Generation und gibt die zwei neue Kinder zurück.
		"""

		global myPoem
		input = web.input()
		print "/do POST: input ist:", input #DEBUG
		print "/do POST: Kinder des Elter sind", myPoem.getChildren() #DEBUG

		# Welches Kind wird neuer Elter?
		if input["child"] == "l":
			myPoem = myPoem.getChildren()[0]
		elif input["child"] == "r":
			myPoem = myPoem.getChildren()[1]
		print "/do POST: Neuer Elter ist:", myPoem.getGenotype() #DEBUG

		# Kinder erzeugen und als JSON-Objekt zurückgeben
		children = myPoem.procreateN(2)
		print "/do POST: Kinder sind erzeugt" #DEBUG
# @TODO: getPhenotype()-Aufrufe in try: except HaikuError-Block einbetten
		return json.dumps([[child.getGenotype(), child.getPhenotype().replace("\n", "<br/>")] for child in children])


if __name__ == '__main__':
	if RUNS_ON_OPENSHIFT:
		from wsgiref.simple_server import make_server
		httpd = make_server('localhost', 80, application)
		httpd.serve_forever()
	else: # starte lokal mit web.py
		app.run()
